<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
    
    /* Add this at the top of your style section */


/* Apply Joystix to all text elements */
body, button, span, div {
    font-family: 'Joystix', monospace;
    letter-spacing: 1px;
}
body {
    margin: 0;
    padding: 0;
    background-color: black;
    display: flex;
    justify-content: center;

}

.wrapper {
    width: 800px;
    transform-origin: top center;
    transform: scale(1);
    transition: transform 0.3s ease;
}
@media (max-width: 768px) {
    .wrapper {
        transform: scale(0.85);
    }
}

@media (max-width: 480px) {
    .wrapper {
        transform: scale(0.75);
    }
}
        .timer {
            background-image: url('images/bg-3.jpg');
            background-size: cover;
            background-position: center;
            padding: 2rem;
            text-align: center;
            color: white;
            border-radius: 10px;
            margin-bottom: 1rem;
        }
        .timer::before {
    content: "‚è±";
    margin-right: 8px;
    font-size: 1.1rem;
}

/* When time is running low (last 5 seconds) */
.timer.warning {
    color: #ff5555;
    border-color: #ff5555;
    animation: pulse 0.5s infinite alternate;
}

@keyframes pulse {
    from { transform: scale(1); }
    to { transform: scale(1.05); }
}
        .place-vote {
            background-image: url('images/bg-4.jpg');
            background-size: cover;
            background-position: center;
            padding: 2rem;
            text-align: center;
            color: white;
            border-radius: 10px;
            margin-bottom: 1rem;
        }
.history-panel {
    position: relative;
    padding: 2rem;
    border-radius: 5px;
    margin-bottom: 1rem;
    overflow: hidden;
    min-height: 400px; /* Add this line to ensure minimum height */
}

.history-panel-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: url('images/coinflipgrid.jpg');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat; /* Add this to prevent repeating */
}
.coin-image {
    width: 100%;
    height: 100%;
    object-fit: contain;
    max-width: 50px; /* Adjust based on your image size */
    max-height: 50px;
}
        .history-content {
            position: relative;
            z-index: 2;
        }
        
        .panel-title {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.5rem;
            text-shadow: 1px 1px 3px black;
        }
        
        .history-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
    gap: 12px; /* Equal gap on all sides */
    margin-left: -30px; /* Counteract padding to align with background */
    margin-right: -31px;
    margin-top: -20px;
        margin-bottom: -25px;

        }
        



        
/* Updated voting section styles */
.place-vote {
    background-image: url('images/bg-4.jpg');
    background-size: cover;
    background-position: center;
    padding: 1.5rem;
    color: white;
    border-radius: 10px;
    margin-bottom: 1rem;
    display: flex;
    flex-direction: column;
}
.vote-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 1.5rem;
    margin-bottom: 1rem;
    text-shadow: 2px 2px 0 #000;
}

.round-number {
    background-color: rgba(0, 0, 0, 0.5);
    padding: 5px 10px;
    border-radius: 5px;
    border: 2px solid #fff;
    font-size: 1.2rem;
    color: gold;
    text-shadow: 2px 2px 0 #000;
}
.main-container {
    width: 800px;
    transform-origin: top center;
    transform: scale(1.2);
    transition: transform 0.3s ease;
    
}

/* Tablet zoom out */
@media (max-width: 768px) {
    .main-container {
        transform: scale(0.75);
    }
}

/* Mobile zoom out more */
@media (max-width: 480px) {
    .main-container {
        transform: scale(0.65);
    }
}
.vote-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.vote-buttons {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 40%;
}

.vote-options {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.vote-btn {
    padding: 12px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;
    text-align: center;
    border: 2px solid #000;
    box-shadow: 3px 3px 0 #000;
    position: relative;
    top: 0;
    left: 0;
}

.vote-btn:hover:not(:disabled) {
    top: -2px;
    left: -2px;
    box-shadow: 5px 5px 0 #000;
}

.vote-btn:active:not(:disabled) {
    top: 2px;
    left: 2px;
    box-shadow: 1px 1px 0 #000;
}

.vote-btn:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    top: 2px;
    left: 2px;
    box-shadow: 1px 1px 0 #000;
}

.heads-btn {
    background-color: #1C4FE1;
    color: white;
}

.tails-btn {
    background-color: #f44336; /* Red */
    color: white;
}

.vote-results {
    width: 55%;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.result-item {
    display: flex;
    align-items: center;
    gap: 10px;
    justify-content: flex-end;
}

.result-label {
    font-size: 0.9rem;
    min-width: 60px;
    text-shadow: 1px 1px 0 #000;
}

.result-bar-container {
    flex-grow: 1;
    height: 20px;
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: 3px;
    overflow: hidden;
    border: 2px solid #000;
}

.bar-fill {
    height: 100%;
    transition: width 0.5s ease;
}

.heads-fill {
    background-color: #1C4FE1; 
}

.tails-fill {
    background-color: #f44336; /* Red */
}

.result-percentage {
    min-width: 40px;
    text-align: right;
    font-size: 0.9rem;
    text-shadow: 1px 1px 0 #000;
}
.round-display {
    position: absolute;
    bottom: 140px;
    left: 72%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.7);
    padding: 8px 15px;
    border-radius: 5px;
    border: 2px solid gold;
    font-family: 'Joystix', monospace;
    color: gold;
    text-shadow: 2px 2px 0 #000;
    font-size: 1.2rem;
    z-index: 3;
}

.round-display span {
    color: white;
    margin-left: 10px;
}
.history-scale-wrapper {
    width: 800px;
    margin: 0 auto;
    transform-origin: top center;
    transform: scale(1);
}
        /* Keep all other existing styles */
    </style>
</head>
<body>
    <div class="main-container">
        <div class="timer" id="vote-timer">20s before voting ends</div>


        <div class="coin-display">
            <div id="round-status"></div>
        </div>

<div class="history-scale-wrapper">
    <div class="history-panel">
        <div class="history-panel-background"></div>
        <div class="history-content">
            <div class="history-grid" id="game-board"></div>
        </div>
    </div>
</div>
<div class = "end">
<div class="place-vote">

    <div class="vote-header">PLACE YOUR VOTE</div>
        <div class="round-display">
        HAND <span id="current-round">1</span> OF 80
    </div>
    <div class="vote-container">
        <div class="vote-buttons">
                 <button id="vote-heads" class="vote-btn heads-btn">Heads</button>
                <button id="vote-tails" class="vote-btn tails-btn">Tails</button>
        </div>
        <div class="vote-results">
            <div class="result-item">
                <span class="result-label">HEADS:</span>
                <div class="result-bar-container">
                    <div class="bar-fill heads-fill" id="heads-bar" style="width: 50%"></div>
                </div>
                <span class="result-percentage" id="heads-votes">0 (0%)</span>
            </div>
            <div class="result-item">
                <span class="result-label">TAILS:</span>
                <div class="result-bar-container">
                    <div class="bar-fill tails-fill" id="tails-bar" style="width: 50%"></div>
                </div>
                <span class="result-percentage" id="tails-votes">0 (0%)</span>
            </div>
        </div>

    </div>
</div></div>
    </div>

    <script>
        // Game state
        const gameState = {
            results: [],
            headsCount: 0,
            tailsCount: 0,
            currentRound: 1,
            maxRounds: 80,
            votes: { heads: 0, tails: 0 },
            roundStartTime: null,
            userVoted: false,
            userVotes: {},
            pulseIndex: 0,
            currentServerRound: 1, // Track server's current round
        };

        // DOM elements
        const gameBoard = document.getElementById('game-board');
        const headsCountEl = document.getElementById('heads-count');
        const tailsCountEl = document.getElementById('tails-count');
        const roundNumberEl = document.getElementById('round-number');
        const currentResultEl = document.getElementById('current-result');
        const coinDisplayEl = document.getElementById('coin-display');
        const voteHeadsBtn = document.getElementById('vote-heads');
        const voteTailsBtn = document.getElementById('vote-tails');
        const voteTimerEl = document.getElementById('vote-timer');
        const headsVotesEl = document.getElementById('heads-votes');
        const tailsVotesEl = document.getElementById('tails-votes');
        const headsBarEl = document.getElementById('heads-bar');
        const tailsBarEl = document.getElementById('tails-bar');
        const roundStatusEl = document.getElementById('round-status');
const currentRoundEl = document.getElementById('current-round'); // Add this line
        // API endpoints
const API_URL = "https://coinflip-production-e982.up.railway.app/api";

        // Initialize game
        async function initializeGame() {
            // Load user's vote history from localStorage
            gameState.userVotes = JSON.parse(localStorage.getItem('userVotes')) || {};
            
            // Fetch current game state from server
            await fetchGameState();
            
            // Start game loop
            startGame();
            startVoting();
        }

        // Fetch game state from server
// Replace the fetchGameState function with this:
async function fetchGameState() {
    try {
        const response = await fetch(`${API_URL}/game`);
        const data = await response.json();
        
        gameState.results = data.results;
        gameState.currentRound = data.currentRound;
        gameState.currentServerRound = data.currentRound;
        gameState.votes = data.votes;
        gameState.timeLeft = data.timeLeft; // Use server's calculated timeLeft
        currentRoundEl.textContent = gameState.currentRound;

        // Rest of your existing code...
        gameState.headsCount = gameState.results.filter(r => r === 'H').length;
        gameState.tailsCount = gameState.results.filter(r => r === 'T').length;
        gameState.userVoted = gameState.userVotes[gameState.currentRound] !== undefined;
        
        renderGame();
        clearVoteIfNewRound();
        updateVoteDisplay();
        updateVoteButtons();
        updateVoteTimer(); // Update timer immediately

    } catch (error) {
        console.error('Error fetching game state:', error);
    }
}


        // Submit a vote to the server
        async function submitVote(choice) {
            try {
                if (gameState.userVoted) {
                    return;
                }

                const response = await fetch(`${API_URL}/vote`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ choice })
                });
                
                if (response.ok) {
                    gameState.userVotes[gameState.currentRound] = choice;
                    localStorage.setItem('userVotes', JSON.stringify(gameState.userVotes));
                    gameState.userVoted = true;
                    updateVoteButtons();
                    await fetchGameState();
                }
            } catch (error) {
                console.error('Error submitting vote:', error);
            }
        }
        // Render the game board
function renderGame() {
    gameBoard.innerHTML = '';
    
    // Create a 12x7 grid (84 positions)
    const columns = 12;
    const rows = 7;
    const totalGrids = columns * rows;
    const totalResults = gameState.results.length;
    
    // Fill the grid column-wise (top to bottom, then left to right)
    // with FIRST result at the start (top-left) and LAST at the end (bottom-right)
    for (let col = 1; col <= columns; col++) {
        for (let row = 1; row <= rows; row++) {
            const gridPosition = (col - 1) * rows + (row - 1);
            const resultIndex = gridPosition; // Direct mapping (no reversal)
            
            const resultEl = document.createElement('div');
            resultEl.className = 'history-item';
            
            // Position the item in the grid
            resultEl.style.gridRow = row;
            resultEl.style.gridColumn = col;
            
            // Check if we have a result for this position
            if (resultIndex < totalResults) {
                const result = gameState.results[resultIndex];
                const img = document.createElement('img');
                
                if (result === 'H') {
                    img.src = 'images/banker.png';
                    img.alt = 'Banker';
                    resultEl.classList.add('heads');
                } else if (result === 'T') {
                    img.src = 'images/player.png';
                    img.alt = 'Player';
                    resultEl.classList.add('tails');
                } else {
                    img.src = 'images/tie.png';
                    img.alt = 'Tie';
                    resultEl.classList.add('tie');
                }
                
                img.className = 'coin-image';
                resultEl.appendChild(img);
            }
            
            gameBoard.appendChild(resultEl);
        }
    }
}

        // Start the game loop
        function startGame() {
            // Refresh game state every second
            setInterval(async () => {
                await fetchGameState();
            }, 1000);
        }

        // Voting functions
        function startVoting() {
            updateVoteButtons();
            
            // Set up vote buttons
            voteHeadsBtn.addEventListener('click', () => castVote('heads'));
            voteTailsBtn.addEventListener('click', () => castVote('tails'));
            
            // Start vote timer
            startVoteTimer();
        }

        async function castVote(choice) {
            if (gameState.userVoted) return;
            
            await submitVote(choice);
        }
        function updateVoteButtons() {
            // Check if server has moved to a new round
            const isNewRound = gameState.currentServerRound !== gameState.currentRound;
            
            // Reset voting status if it's a new round
            if (isNewRound) {
                gameState.userVoted = false;
                gameState.currentServerRound = gameState.currentRound;
            }
            
            // Disable voting if user already voted this round
            const shouldDisable = gameState.userVoted;
            voteHeadsBtn.disabled = shouldDisable;
            voteTailsBtn.disabled = shouldDisable;
            
            if (gameState.userVoted) {
                const userChoice = gameState.userVotes[gameState.currentRound];
                roundStatusEl.style.color = userChoice === 'heads' ? 'var(--heads-color)' : 'var(--tails-color)';
                roundStatusEl.style.fontWeight = 'bold';
            } else {
                roundStatusEl.style.color = 'var(--accent-gold)';
            }
        }



        function updateVoteDisplay() {
            const totalVotes = gameState.votes.heads + gameState.votes.tails;
            
            if (totalVotes > 0) {
                const headsPercentage = Math.round((gameState.votes.heads / totalVotes) * 100);
                const tailsPercentage = 100 - headsPercentage;
                
                headsVotesEl.textContent = `${gameState.votes.heads} (${headsPercentage}%)`;
                tailsVotesEl.textContent = `${gameState.votes.tails} (${tailsPercentage}%)`;
                
                headsBarEl.style.width = `${headsPercentage}%`;
                tailsBarEl.style.width = `${tailsPercentage}%`;
            } else {
                headsVotesEl.textContent = "0 (0%)";
                tailsVotesEl.textContent = "0 (0%)";
                headsBarEl.style.width = "0%";
                tailsBarEl.style.width = "0%";
            }
        }

        function startVoteTimer() {
            // Set initial timer display
            updateVoteTimer();
            
            // Update timer every second
            setInterval(() => {
                updateVoteTimer();
            }, 1000);
        }

function updateVoteTimer() {
    if (typeof gameState.timeLeft !== 'number') return;
    
    const secondsLeft = Math.ceil(gameState.timeLeft / 1000);
    const displaySeconds = Math.min(20, Math.max(0, secondsLeft)); // Ensure 0-20 range
    
    voteTimerEl.textContent = `${displaySeconds}s before voting ends`;
    
    // Add/remove warning class
    if (displaySeconds <= 5) {
        voteTimerEl.classList.add('warning');
    } else {
        voteTimerEl.classList.remove('warning');
    }
    
    // Disable buttons when time is up or user voted
    const shouldDisable = displaySeconds <= 0 || gameState.userVoted;
    voteHeadsBtn.disabled = shouldDisable;
    voteTailsBtn.disabled = shouldDisable;
}
function clearVoteIfNewRound() {
        // Only clear votes from previous rounds, not current round
        const savedVotes = JSON.parse(localStorage.getItem('userVotes')) || {};
        
        // Check if we have votes from previous rounds
        const hasPreviousRoundVotes = Object.keys(savedVotes).some(round => 
            parseInt(round) < gameState.currentRound
        );
        
        if (hasPreviousRoundVotes) {
            // Create new votes object with only current round vote (if exists)
            const newVotes = {};
            if (savedVotes[gameState.currentRound]) {
                newVotes[gameState.currentRound] = savedVotes[gameState.currentRound];
            }
            
            localStorage.setItem('userVotes', JSON.stringify(newVotes));
            gameState.userVoted = newVotes[gameState.currentRound] !== undefined;
        }}     // Initialize when page loads
        window.addEventListener('DOMContentLoaded', initializeGame);
    </script>
</body>
</html>